


//support up to 6 blend layers. can easily modify your shader to use more by increasing this value and adding the extra defines to support them
#for i=0..6 ( $0 )
    #ifdef BLENDLAYER_$i    
        uniform vec4 m_BlendLayer_$i_BlendVec; //note that this needs to be a vec4 to store all possible blending vals that change every frame, as to avoid the lag from changing a float parm every frame
    
        uniform vec4 m_BlendLayer_$i_BaseColor; 
        uniform vec3 m_BlendLayer_$i_HSVScalar;
        uniform float m_BlendLayer_$i_NormalIntensity; 

        uniform float m_BlendLayer_$i_Roughness;
        uniform float m_BlendLayer_$i_Metallic;    
        uniform float m_BlendLayer_$i_AoStrength;    
        
        uniform vec4 m_BlendLayer_$i_EmissiveColor;
        uniform float m_BlendLayer_$i_EmissiveIntensity;
        
        #ifdef BLENDLAYER_$i_HEIGHTBLENDMODE
            uniform float floorHeightPercent; //if this is (for example) 0.2f
            uniform float roofHeightPercent;
            uniform float heightEdgeBlend;
            
        #endif
        
        #ifdef BLENDLAYER_$i_NOISEDISSOLVE
            //use a noise based map or noise equations for dissolve or dissolve-like blending effects
            
            uniform vec4 DissolveEdgeColor;
            uniform float DisolveEdgeThickness;
        #endif
        
        #ifdef BLENDLAYER_$i_BASECOLORMAP
            uniform sampler2D m_BlendLayer_$i_BaseColorMap;
        #endif

        #ifdef BLENDLAYER_$i_NORMALMAP
            uniform sampler2D m_BlendLayer_$i_NormalMap;
        #endif    

        #ifdef BLENDLAYER_$i_METALLICROUGHNESSAOMAP
            uniform sampler2D m_BlendLayer_$i_MetallicRoughnessAoMap; //not setup to use individual roughness and metallic maps since that is less optimized, but can easily add them if needed
        #endif

        #ifdef BLENDLAYER_$i_EMISSIVEMAP
            uniform sampler2D m_BlendLayer_$i_EmissiveMap;
        #endif
    #endif
#endfor 

vec3 rgb2hsv(vec3 c){
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c){
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec4 getTriPlanarBlend(in vec3 coords, in vec3 blending, in sampler2D map, in float scale) {
      vec4 col1 = texture2D( map, coords.yz * scale);
      vec4 col2 = texture2D( map, coords.xz * scale);
      vec4 col3 = texture2D( map, coords.xy * scale); 
      
      col1.xyz = (col1.xyz * vec3(2.0, 2.0, 2.0) - vec3(1.0, 1.0, 1.0)) * vec3(1.0).xyz;
      col2.xyz = (col2.xyz * vec3(2.0, 2.0, 2.0) - vec3(1.0, 1.0, 1.0)) * vec3(1.0).xyz;
      col3.xyz = (col3.xyz * vec3(2.0, 2.0, 2.0) - vec3(1.0, 1.0, 1.0)) * vec3(1.0).xyz;
      // blend the results of the 3 planar projections.
      vec4 tex = col1 * blending.x + col2 * blending.y + col3 * blending.z;
      
      return tex;
}


void blendLayer(in int layerIndex, inout vec4 albedo, inout float Roughness, inout float Metallic, inout float ao){
    
    
//    #for l=layerIndex..layerIndex ( $0 )
//        #ifdef BLENDPERCENT_$l

//        #endif
//    #endfor
    
    
}


vec3 rnmBlendUnpacked(vec3 n1, vec3 n2){
    n1 += vec3( 0.0,  0.0, 1.0);
    n2 *= vec3(-1.0, -1.0, 1.0);
    return n1*dot(n1, n2)/n1.z - n2;
}


vec3 calculateBetterTriplanar(in vec3 blend, in vec3 worldNormal, in vec3 worldPos, in sampler2D map, in float scale) {

    float normalScale = 1.0;

        // Triplanar uvs
    vec2 uvX = worldPos.zy; // x facing plane
    vec2 uvY = worldPos.xz; // y facing plane
    vec2 uvZ = worldPos.xy; // z facing plane
    // Tangent space normal maps
    vec3 tnormalX = texture2D(map, uvX * scale).xyz;
    vec3 tnormalY = texture2D(map, uvY * scale).xyz;
    vec3 tnormalZ = texture2D(map, uvZ * scale).xyz;
    
    tnormalX.xy *= vec2(normalScale);
    tnormalY.xy *= vec2(normalScale);
    tnormalZ.xy *= vec2(normalScale);
     
  //  tnormalX = normalize((tnormalX.xyz * vec3(2.0, 2.0, 2.0) - vec3(1.0, 1.0, 1.0)) * vec3(normalScale, normalScale, 1.0));
  //  tnormalY = normalize((tnormalY.xyz * vec3(2.0, 2.0, 2.0) - vec3(1.0, 1.0, 1.0)) * vec3(normalScale, normalScale, 1.0));
  //  tnormalZ = normalize((tnormalZ.xyz * vec3(2.0, 2.0, 2.0) - vec3(1.0, 1.0, 1.0)) * vec3(normalScale, normalScale, 1.0));
    
    // Get absolute value of normal to ensure positive tangent "z" for blend
    vec3 absVertNormal = abs(worldNormal);
    // Swizzle world normals to match tangent space and apply RNM blend
    tnormalX = rnmBlendUnpacked(vec3(worldNormal.zy, absVertNormal.x), tnormalX);
    tnormalY = rnmBlendUnpacked(vec3(worldNormal.xz, absVertNormal.y), tnormalY);
    tnormalZ = rnmBlendUnpacked(vec3(worldNormal.xy, absVertNormal.z), tnormalZ);
    // Get the sign (-1 or 1) of the surface normal
    vec3 axisSign = sign(worldNormal);
    // Reapply sign to Z
    tnormalX.z *= axisSign.x;
    tnormalY.z *= axisSign.y;
    tnormalZ.z *= axisSign.z;
    
    vec3 normalX = vec3(0.0, tnormalX.yx);
    vec3 normalY = vec3(tnormalY.x, 0.0, tnormalY.y);
    vec3 normalZ = vec3(tnormalZ.xy, 0.0);


    // Triblend normals and add to world normal
    vec3 returnNormal = normalize(
        normalX.xyz * blend.x +
        normalY.xyz * blend.y +
        normalZ.xyz * blend.z +
        worldNormal
        );
        
    return returnNormal;

}

vec4 calculateBetterTriplanarColor( in vec3 worldPos, in vec3 blend, in sampler2D map, float scale) {
    // Triplanar uvs
    vec2 uvX = worldPos.zy; // x facing plane
    vec2 uvY = worldPos.xz; // y facing plane
    vec2 uvZ = worldPos.xy; // z facing plane
    
    // Sample colors from the colormap along each axis
    vec4 colorX = texture2D(map, uvX * scale);
    vec4 colorY = texture2D(map, uvY * scale);
    vec4 colorZ = texture2D(map, uvZ * scale);
    
    // Blend the sampled colors based on the surface position
    vec3 blendedColor = colorX.rgb * blend.x + colorY.rgb * blend.y + colorZ.rgb * blend.z;
    
    // Blend the alpha values based on the surface position
    float blendedAlpha = colorX.a * blend.x + colorY.a * blend.y + colorZ.a * blend.z;
    
    return vec4(blendedColor, blendedAlpha);
}


void applyAllBlendEffects(inout vec4 albedo, inout vec3 normal, inout float Roughness, inout float Metallic, inout vec3 ao, inout vec4 emissive, inout float glossiness, in vec2 texCoord, in vec3 wPosition, in vec3 norm, in mat3 tbnMat){
    
    //glossiness wlil be converted to roughness by just doing:
    
    #ifdef SPECGLOSSPIPELINE
        Roughness = 1.0 - glossiness;
    #endif
        
    vec3 blending = abs( norm );
    blending = (blending -0.2) * 0.7;
    blending = normalize(max(blending, 0.00001));      // Force weights to sum to 1.0 (very important!)
    float b = (blending.x + blending.y + blending.z);
    blending /= vec3(b, b, b);
    
    
    blending = abs(norm);
    blending = (blending - 0.2) * 0.7;
    blending = normalize(max(blending, 0.00001)); // Ensure weights sum to 1.0

   // blending = abs(normalize(wPosition));
    
    float triScale = 0.5;
    
    vec3 blend = blending;
    
    vec4 newAlbedo, newEmissive, packedMetallicRoughnessAoVec;
    vec3 newNormal;    
    float blendPercent, newRoughness, newMetallic, newAo;
    
    float newAlpha;
    
    float modelHeight = 2.0;
    float modelYPos = 0.0;

    float minHeightWorld = 0.0;
    float maxHeightWorld = blendPercent * 2.0;
    
    float noiseVal;
    
    float dissolveBlendPercent;
    
    float heightScanLowerPercent;
    float heighScanUpperPercent;
        
  //  albedo.xyz = vec3(0.9,0.92,0.96);

    #for i=0..6 ( $0 )
    
      //  blendLayer($i, albedo, Roughness, Metallic, ao);
    
        #ifdef BLENDLAYER_$i    
            newAlbedo = vec4(1.0);
            newEmissive = vec4(1.0);
            packedMetallicRoughnessAoVec.rgb = vec3(1.0);
            blendPercent = 0.0;
            newRoughness = 1.0;
            newMetallic = 1.0;
            newAo = 1.0;
            noiseVal = 0.0;    
            newAlpha = 1.0;
            newNormal = normal;

            blendPercent = m_BlendLayer_$i_BlendVec.x;
            heightScanLowerPercent = m_BlendLayer_$i_BlendVec.y;
            heighScanUpperPercent = m_BlendLayer_$i_BlendVec.z;
            dissolveBlendPercent = m_BlendLayer_$i_BlendVec.w;
             
             
             
             // --- height blending wip:
             

            minHeightWorld = 0.0; //add minHeightOffset from blendVec.y eventually
            maxHeightWorld = heighScanUpperPercent * modelHeight; // and blendVec.z here for maxHeightScan                    

            if(wPosition.y < maxHeightWorld){
               blendPercent *= 1.0; 
            }else{
               blendPercent = 0.0;
            }

             // ---
             
             //dissolve ---

             //hard coded noise inputs currently... add params for multiple layers of noise with custom frequency and amplitude eventually
            noiseVal = Noise3D(scaledModelPos, 0.123) + 0.00001 ;
            
            if(dissolveBlendPercent > noiseVal){
                
                blendPercent*= 1.0;
                //discard;
            }else{
                blendPercent = 0.0;
            }

            //---


            #ifdef BLENDLAYER_$i_BASECOLORMAP
                #ifdef BLENDLAYER_$i_TRIPLANAR    
                    newAlbedo = calculateBetterTriplanarColor(wPosition, blending, m_BlendLayer_$i_BaseColorMap, triScale);
                #else
                    newAlbedo = texture2D(m_BlendLayer_$i_BaseColorMap, texCoord);
                #endif
            #endif
            
            //modify albedo color in HSV space (does nothing if default value for m_BlendLayer_$i_HSVScalar is left as 1,1,1)
            newAlbedo.rgb = rgb2hsv(newAlbedo.rgb).rgb; //could probably put this HSV scaling in an #ifdef once this shader is running on a newer version of jme that supports >64 defines per shader. but for now have to be conservative with defines
            
            newAlbedo.x += m_BlendLayer_$i_HSVScalar.x;         //modify hue
            newAlbedo.y += m_BlendLayer_$i_HSVScalar.y ;       //modify saturation
            newAlbedo.z += m_BlendLayer_$i_HSVScalar.z;       //modify value(brightness)
            
            #ifdef BLENDLAYER_$i_COLORCYCLEEFFECT
                if(m_ColorCycleEffectVector.x > 0){
                    newAlbedo.x += (g_Time * m_ColorCycleEffectVector.x); // cycle through all hues of color for fancy effect        
                }
                if(m_ColorCycleEffectVector.y > 0){
                    newAlbedo.y = mod((g_Time * m_ColorCycleEffectVector.y) + 1, 1); //scale saturation over time for fancy effect     
                }
                if(m_ColorCycleEffectVector.z > 0){
                    newAlbedo.z = mod((g_Time * m_ColorCycleEffectVector.z) + 1, 1); //scale brithness over time for fancy effect
                }
            #endif

            newAlbedo.x = mod(newAlbedo.x + 1, 1);  //keep hue values in range of 0-1 in cases where added values makes it over 1


            // max and min all final HSV values to be between 0-1
            newAlbedo.x = max(newAlbedo.x, 0.0);
            newAlbedo.x = min(newAlbedo.x, 1.0);

            newAlbedo.y = max(newAlbedo.y, 0.0);
            newAlbedo.y = min(newAlbedo.y, 1.0);

            newAlbedo.z = max(newAlbedo.z, 0.0);
            newAlbedo.z = min(newAlbedo.z, 1.0);

            //convert back to RGB and set albedo's new color
            newAlbedo.rgb = hsv2rgb(newAlbedo.rgb).rgb;
            
            //multiply the regular color param after applying hsv, that way you can use full desaturation in HSV space then multiply by a color for more precise color selections 
            newAlbedo *= m_BlendLayer_$i_BaseColor;
            
            newAlpha = newAlbedo.a;
            
            #ifdef BLENDLAYER_$i_BLENDALPHA
                blendPercent *= newAlpha; //use alpha layer as multiplier for blend value
            #else    
                
            #endif
            
            albedo = mix(albedo, newAlbedo, blendPercent);    
            alpha = mix(alpha, newAlpha, blendPercent);
            

            
            #ifdef BLENDLAYER_$i_NORMALMAP
                #ifdef BLENDLAYER_$i_TRIPLANAR    
                
                    newNormal = getTriPlanarBlend(wPosition, blend, m_BlendLayer_$i_NormalMap, triScale ).xyz;
             //       newNormal = normalize((newNormal.xyz * vec3(2.0, 2.0, 2.0) - vec3(1.0, 1.0, 1.0))) * vec3(1.0);
                    newNormal = normalize(tbnMat * newNormal);       //currently broken...
                    
                #else
                    newNormal = texture2D(m_BlendLayer_$i_NormalMap, texCoord).xyz; //non triplanar use for pre-made texture atlases
                    newNormal = normalize((newNormal.xyz * vec3(2.0,  2.0, 2.0) - vec3(1.0, NORMAL_TYPE * 1.0, 1.0)));
                    newNormal = normalize(tbnMat * newNormal);                    
                #endif
            #endif
            normal = mix(normal, newNormal, blendPercent);     
            
            
            newRoughness = m_BlendLayer_$i_Roughness;
            newMetallic = m_BlendLayer_$i_Metallic;
            newAo = m_BlendLayer_$i_AoStrength;
            
            #ifdef BLENDLAYER_$i_METALLICROUGHNESSAOMAP
                #ifdef BLENDLAYER_$i_TRIPLANAR             
                    packedMetallicRoughnessAoVec = calculateBetterTriplanarColor(wPosition, blending, m_BlendLayer_$i_MetallicRoughnessAoMap, triScale);
                #else
                    packedMetallicRoughnessAoVec = texture2D(m_BlendLayer_$i_MetallicRoughnessAoMap, texCoord);
                #endif
                newRoughness *= packedMetallicRoughnessAoVec.g;
                newMetallic *= packedMetallicRoughnessAoVec.b;
                newAo *= packedMetallicRoughnessAoVec.r;
            #endif
            
            Roughness = mix(Roughness, newRoughness, blendPercent);
            Metallic = mix(Metallic, newMetallic, blendPercent);
            ao.rgb = mix(ao.rgb, vec3(newAo), blendPercent);

            #ifdef BLENDLAYER_$i_EMISSIVEMAP            
                #ifdef BLENDLAYER_$i_TRIPLANAR     
                    newEmissive = calculateBetterTriplanarColor(wPosition, blending, m_BlendLayer_$i_EmissiveMap, triScale); 
                #else
                    newEmissive = texture2D(m_BlendLayer_$i_EmissiveMap, texCoord);
                #endif
            #endif        
            
            newEmissive *= m_BlendLayer_$i_EmissiveColor;            
            newEmissive *= m_BlendLayer_$i_EmissiveIntensity;
            
            emissive = mix(emissive, newEmissive, blendPercent);
            
        #endif
    
    #endfor
    
        if(alpha < 0.001){
            discard;
        }
    
    //convert roughness back to glossiness in case spec gloss is being used by the main shader:
    glossiness = 1.0 - Roughness;
}
